<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sd-reader: Partition table support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Partition table support</h1>  </div>
</div>
<div class="contents">

<p>Support for reading partition tables and access to partitions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpartition__struct.html">partition_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a partition.  <a href="structpartition__struct.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition__config.html">Configuration of partition table support</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Preprocessor defines to configure the partition support. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="partition_8c.html">partition.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Partition table implementation (license: GPLv2 or LGPLv2.1). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="partition_8h.html">partition.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Partition table header (license: GPLv2 or LGPLv2.1). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="partition__config_8h.html">partition_config.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Partition configuration (license: GPLv2 or LGPLv2.1). </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab5ffe2ef6119a6815c505e3103a2714"></a><!-- doxytag: member="partition::PARTITION_TYPE_FREE" ref="gaab5ffe2ef6119a6815c505e3103a2714" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gaab5ffe2ef6119a6815c505e3103a2714">PARTITION_TYPE_FREE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition table entry is not used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa92b6c552d2411e093204cd3ed4cffa3"></a><!-- doxytag: member="partition::PARTITION_TYPE_FAT12" ref="gaa92b6c552d2411e093204cd3ed4cffa3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gaa92b6c552d2411e093204cd3ed4cffa3">PARTITION_TYPE_FAT12</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition contains a FAT12 filesystem. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf7296b4a29c1f7e5c39e28372648b2cd"></a><!-- doxytag: member="partition::PARTITION_TYPE_FAT16_32MB" ref="gaf7296b4a29c1f7e5c39e28372648b2cd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gaf7296b4a29c1f7e5c39e28372648b2cd">PARTITION_TYPE_FAT16_32MB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition contains a FAT16 filesystem with 32MB maximum. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaceaa1bf17d4e8961726834e53ed79732"></a><!-- doxytag: member="partition::PARTITION_TYPE_EXTENDED" ref="gaceaa1bf17d4e8961726834e53ed79732" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gaceaa1bf17d4e8961726834e53ed79732">PARTITION_TYPE_EXTENDED</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition is an extended partition with its own partition table. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada7e1b4d950c7a3f42f559ab99f5fe43"></a><!-- doxytag: member="partition::PARTITION_TYPE_FAT16" ref="gada7e1b4d950c7a3f42f559ab99f5fe43" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gada7e1b4d950c7a3f42f559ab99f5fe43">PARTITION_TYPE_FAT16</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition contains a FAT16 filesystem. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f6a6c30cc239ae13ea287ff901c95f4"></a><!-- doxytag: member="partition::PARTITION_TYPE_FAT32" ref="ga2f6a6c30cc239ae13ea287ff901c95f4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga2f6a6c30cc239ae13ea287ff901c95f4">PARTITION_TYPE_FAT32</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition contains a FAT32 filesystem. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2e0c8e8b4ec10f7b342c0d554b5f6d8"></a><!-- doxytag: member="partition::PARTITION_TYPE_FAT32_LBA" ref="gaa2e0c8e8b4ec10f7b342c0d554b5f6d8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gaa2e0c8e8b4ec10f7b342c0d554b5f6d8">PARTITION_TYPE_FAT32_LBA</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition contains a FAT32 filesystem with LBA. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga52b69fda008ca19d75304a2385cc4900"></a><!-- doxytag: member="partition::PARTITION_TYPE_FAT16_LBA" ref="ga52b69fda008ca19d75304a2385cc4900" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga52b69fda008ca19d75304a2385cc4900">PARTITION_TYPE_FAT16_LBA</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition contains a FAT16 filesystem with LBA. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c9a00e3b09b488ce7f3b2ef2904400b"></a><!-- doxytag: member="partition::PARTITION_TYPE_EXTENDED_LBA" ref="ga1c9a00e3b09b488ce7f3b2ef2904400b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga1c9a00e3b09b488ce7f3b2ef2904400b">PARTITION_TYPE_EXTENDED_LBA</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition is an extended partition with LBA. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacdc50585fe8130f0a4faee13caade86f"></a><!-- doxytag: member="partition::PARTITION_TYPE_UNKNOWN" ref="gacdc50585fe8130f0a4faee13caade86f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gacdc50585fe8130f0a4faee13caade86f">PARTITION_TYPE_UNKNOWN</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The partition has an unknown type. <br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga52bf225ef74664c7e596f23d8d807c85">device_read_t</a> )(offset_t offset, uint8_t *buffer, uintptr_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function pointer used to read from the partition.  <a href="#ga52bf225ef74664c7e596f23d8d807c85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga23a54af15a8c9711925e8b2e3433a27d">device_read_callback_t</a> )(uint8_t *buffer, offset_t offset, void *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function pointer passed to a <code>device_read_interval_t</code>.  <a href="#ga23a54af15a8c9711925e8b2e3433a27d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#gae89b7507ba9787aec1e8974c5f2b30a4">device_read_interval_t</a> )(offset_t offset, uint8_t *buffer, uintptr_t interval, uintptr_t length, <a class="el" href="group__partition.html#ga23a54af15a8c9711925e8b2e3433a27d">device_read_callback_t</a> callback, void *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function pointer used to continuously read units of <code>interval</code> bytes and call a callback function.  <a href="#gae89b7507ba9787aec1e8974c5f2b30a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga8d202a969ce237e5876b1f1f506df53f">device_write_t</a> )(offset_t offset, const uint8_t *buffer, uintptr_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function pointer used to write to the partition.  <a href="#ga8d202a969ce237e5876b1f1f506df53f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uintptr_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga3199d1b591458c7c6664545fab7d32fe">device_write_callback_t</a> )(uint8_t *buffer, offset_t offset, void *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function pointer passed to a <code>device_write_interval_t</code>.  <a href="#ga3199d1b591458c7c6664545fab7d32fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga032324dc0780bc62cd91a8856ffe0800">device_write_interval_t</a> )(offset_t offset, uint8_t *buffer, uintptr_t length, <a class="el" href="group__partition.html#ga3199d1b591458c7c6664545fab7d32fe">device_write_callback_t</a> callback, void *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function pointer used to continuously write a data stream obtained from a callback function.  <a href="#ga032324dc0780bc62cd91a8856ffe0800"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpartition__struct.html">partition_struct</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga3125023db4e9d50adb8489c71fa1be68">partition_open</a> (<a class="el" href="group__partition.html#ga52bf225ef74664c7e596f23d8d807c85">device_read_t</a> device_read, <a class="el" href="group__partition.html#gae89b7507ba9787aec1e8974c5f2b30a4">device_read_interval_t</a> device_read_interval, <a class="el" href="group__partition.html#ga8d202a969ce237e5876b1f1f506df53f">device_write_t</a> device_write, <a class="el" href="group__partition.html#ga032324dc0780bc62cd91a8856ffe0800">device_write_interval_t</a> device_write_interval, int8_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a partition.  <a href="#ga3125023db4e9d50adb8489c71fa1be68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__partition.html#ga128f4363de35c81a9ff8026d4db289d2">partition_close</a> (struct <a class="el" href="structpartition__struct.html">partition_struct</a> *partition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a partition.  <a href="#ga128f4363de35c81a9ff8026d4db289d2"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Support for reading partition tables and access to partitions. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga23a54af15a8c9711925e8b2e3433a27d"></a><!-- doxytag: member="partition.h::device_read_callback_t" ref="ga23a54af15a8c9711925e8b2e3433a27d" args=")(uint8_t *buffer, offset_t offset, void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t(* <a class="el" href="group__partition.html#ga23a54af15a8c9711925e8b2e3433a27d">device_read_callback_t</a>)(uint8_t *buffer, offset_t offset, void *p)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function pointer passed to a <code>device_read_interval_t</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer which contains the data just read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset from which the data in <code>buffer</code> was read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>An opaque pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__partition.html#gae89b7507ba9787aec1e8974c5f2b30a4" title="A function pointer used to continuously read units of interval bytes and call a callback function...">device_read_interval_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae89b7507ba9787aec1e8974c5f2b30a4"></a><!-- doxytag: member="partition.h::device_read_interval_t" ref="gae89b7507ba9787aec1e8974c5f2b30a4" args=")(offset_t offset, uint8_t *buffer, uintptr_t interval, uintptr_t length, device_read_callback_t callback, void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t(* <a class="el" href="group__partition.html#gae89b7507ba9787aec1e8974c5f2b30a4">device_read_interval_t</a>)(offset_t offset, uint8_t *buffer, uintptr_t interval, uintptr_t length, <a class="el" href="group__partition.html#ga23a54af15a8c9711925e8b2e3433a27d">device_read_callback_t</a> callback, void *p)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function pointer used to continuously read units of <code>interval</code> bytes and call a callback function. </p>
<p>This function starts reading at the specified offset. Every <code>interval</code> bytes, it calls the callback function with the associated data buffer.</p>
<p>By returning zero, the callback may stop reading.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset from which to start reading. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to a buffer which is at least interval bytes in size. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interval</em>&nbsp;</td><td>Number of bytes to read before calling the callback function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Number of bytes to read altogether. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>The function to call every interval bytes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>An opaque pointer directly passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__partition.html#ga52bf225ef74664c7e596f23d8d807c85" title="A function pointer used to read from the partition.">device_read_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga52bf225ef74664c7e596f23d8d807c85"></a><!-- doxytag: member="partition.h::device_read_t" ref="ga52bf225ef74664c7e596f23d8d807c85" args=")(offset_t offset, uint8_t *buffer, uintptr_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t(* <a class="el" href="group__partition.html#ga52bf225ef74664c7e596f23d8d807c85">device_read_t</a>)(offset_t offset, uint8_t *buffer, uintptr_t length)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function pointer used to read from the partition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset on the device where to start reading. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer into which to place the data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The count of bytes to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3199d1b591458c7c6664545fab7d32fe"></a><!-- doxytag: member="partition.h::device_write_callback_t" ref="ga3199d1b591458c7c6664545fab7d32fe" args=")(uint8_t *buffer, offset_t offset, void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t(* <a class="el" href="group__partition.html#ga3199d1b591458c7c6664545fab7d32fe">device_write_callback_t</a>)(uint8_t *buffer, offset_t offset, void *p)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function pointer passed to a <code>device_write_interval_t</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer which receives the data to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset to which the data in <code>buffer</code> will be written. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>An opaque pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes put into <code>buffer</code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__partition.html#ga032324dc0780bc62cd91a8856ffe0800" title="A function pointer used to continuously write a data stream obtained from a callback function...">device_write_interval_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga032324dc0780bc62cd91a8856ffe0800"></a><!-- doxytag: member="partition.h::device_write_interval_t" ref="ga032324dc0780bc62cd91a8856ffe0800" args=")(offset_t offset, uint8_t *buffer, uintptr_t length, device_write_callback_t callback, void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t(* <a class="el" href="group__partition.html#ga032324dc0780bc62cd91a8856ffe0800">device_write_interval_t</a>)(offset_t offset, uint8_t *buffer, uintptr_t length, <a class="el" href="group__partition.html#ga3199d1b591458c7c6664545fab7d32fe">device_write_callback_t</a> callback, void *p)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function pointer used to continuously write a data stream obtained from a callback function. </p>
<p>This function starts writing at the specified offset. To obtain the next bytes to write, it calls the callback function. The callback fills the provided data buffer and returns the number of bytes it has put into the buffer.</p>
<p>By returning zero, the callback may stop writing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset where to start writing. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to a buffer which is used for the callback function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Number of bytes to write in total. May be zero for endless writes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>The function used to obtain the bytes to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>An opaque pointer directly passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__partition.html#ga8d202a969ce237e5876b1f1f506df53f" title="A function pointer used to write to the partition.">device_write_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d202a969ce237e5876b1f1f506df53f"></a><!-- doxytag: member="partition.h::device_write_t" ref="ga8d202a969ce237e5876b1f1f506df53f" args=")(offset_t offset, const uint8_t *buffer, uintptr_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t(* <a class="el" href="group__partition.html#ga8d202a969ce237e5876b1f1f506df53f">device_write_t</a>)(offset_t offset, const uint8_t *buffer, uintptr_t length)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function pointer used to write to the partition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset on the device where to start writing. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer which to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The count of bytes to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga128f4363de35c81a9ff8026d4db289d2"></a><!-- doxytag: member="partition.c::partition_close" ref="ga128f4363de35c81a9ff8026d4db289d2" args="(struct partition_struct *partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t partition_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpartition__struct.html">partition_struct</a> *&nbsp;</td>
          <td class="paramname"> <em>partition</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes a partition. </p>
<p>This function destroys a partition descriptor which was previously obtained from a call to <a class="el" href="group__partition.html#ga3125023db4e9d50adb8489c71fa1be68" title="Opens a partition.">partition_open()</a>. When this function returns, the given descriptor will be invalid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>partition</em>&nbsp;</td><td>The partition descriptor to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, 1 on success. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__partition.html#ga3125023db4e9d50adb8489c71fa1be68" title="Opens a partition.">partition_open</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3125023db4e9d50adb8489c71fa1be68"></a><!-- doxytag: member="partition.c::partition_open" ref="ga3125023db4e9d50adb8489c71fa1be68" args="(device_read_t device_read, device_read_interval_t device_read_interval, device_write_t device_write, device_write_interval_t device_write_interval, int8_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpartition__struct.html">partition_struct</a> * partition_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__partition.html#ga52bf225ef74664c7e596f23d8d807c85">device_read_t</a>&nbsp;</td>
          <td class="paramname"> <em>device_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__partition.html#gae89b7507ba9787aec1e8974c5f2b30a4">device_read_interval_t</a>&nbsp;</td>
          <td class="paramname"> <em>device_read_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__partition.html#ga8d202a969ce237e5876b1f1f506df53f">device_write_t</a>&nbsp;</td>
          <td class="paramname"> <em>device_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__partition.html#ga032324dc0780bc62cd91a8856ffe0800">device_write_interval_t</a>&nbsp;</td>
          <td class="paramname"> <em>device_write_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a partition. </p>
<p>Opens a partition by its index number and returns a partition handle which describes the opened partition.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function does not support extended partitions.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device_read</em>&nbsp;</td><td>A function pointer which is used to read from the disk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device_read_interval</em>&nbsp;</td><td>A function pointer which is used to read in constant intervals from the disk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device_write</em>&nbsp;</td><td>A function pointer which is used to write to the disk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device_write_interval</em>&nbsp;</td><td>A function pointer which is used to write a data stream to disk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the partition which should be opened, range 0 to 3. A negative value is allowed as well. In this case, the partition opened is not checked for existance, begins at offset zero, has a length of zero and is of an unknown type. Use this in case you want to open the whole device as a single partition (e.g. for "super floppy" use). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, a partition descriptor on success. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__partition.html#ga128f4363de35c81a9ff8026d4db289d2" title="Closes a partition.">partition_close</a> </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Apr 23 2011 15:30:12 for sd-reader by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
