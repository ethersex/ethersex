/*
 * Copyright (c) 2010 by Stefan Riepenhausen <rhn@gmx.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * For more information on the GPL, please go to:
 * http://www.gnu.org/copyleft/gpl.html
 */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <util/delay.h>
#include <avr/wdt.h>
#include <avr/pgmspace.h>

#include "config.h"
#include "requests.h"
#include "usb_hid_mouse.h"
#include "usbdrv/usbdrv.h"

#include "protocols/ecmd/ecmd-base.h"

#ifdef USB_MOUSE_SUPPORT

static	unsigned char volatile	flags = 0;
static	uchar    				reportBuffer[3];    

#define FLG_CMD_RECEIVED	0x01
#define FLG_MAKING_REPORT	0x02
#define FLG_SENDING_REPORT	0x04
#define FLG_IGNORE_PACKET	0x08

// generated by usb.org's HIDTool for standard mouse
// probably you want (must?!) to change it if you need mouse's wheel support
PROGMEM const char usbHidReportDescriptor[] = { /* USB report descriptor */
    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
    0x09, 0x02,                    // USAGE (Mouse)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x09, 0x01,                    //   USAGE (Pointer)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x05, 0x09,                    //     USAGE_PAGE (Button)
    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
    0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x75, 0x05,                    //     REPORT_SIZE (5)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
    0x09, 0x30,                    //     USAGE (X)
    0x09, 0x31,                    //     USAGE (Y)
    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x02,                    //     REPORT_COUNT (2)
    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
    0xc0,                          //   END_COLLECTION
    0xc0                           // END_COLLECTION
};

void
usb_mouse_periodic(void) {
	if (flags & FLG_CMD_RECEIVED) {
		if (usbInterruptIsReady()){
			usbSetInterrupt(reportBuffer, sizeof(reportBuffer));
		}
		flags &= ~FLG_CMD_RECEIVED;
	}
}

#ifdef USB_MOUSE_SEQUENCE_SUPPORT
#include "usb_hid_mouse_map.h"
  uint8_t mouseposcounter=0;
#endif

void
usb_mouse_periodic_call (void)
{
//	USBMOUSEDEBUG("pre mouse send\n");
#ifdef  USB_MOUSE_SEQUENCE_SUPPORT
//	reportBuffer[0]=0; // button
//	reportBuffer[1]=1; // delta x
//	reportBuffer[2]=-1; // delta y
    if (flags & FLG_CMD_RECEIVED) {
       return;
    }
    struct hid_mouse_map_t mousemap; 
    memcpy_P(&mousemap, &mousepos[mouseposcounter], sizeof(struct hid_mouse_map_t));
	USBMOUSEDEBUG("sequence: pos %u, button=%u, dx=%i, dy=%i\n",mouseposcounter, mousemap.button,mousemap.deltax,mousemap.deltay);
	reportBuffer[0]=mousemap.button;
	reportBuffer[1]=mousemap.deltax;
	reportBuffer[2]=mousemap.deltay;
    mouseposcounter++;
    if (mouseposcounter >= (sizeof(mousepos) / sizeof(struct hid_mouse_map_t))) {
      mouseposcounter=0;
    }
	flags = FLG_CMD_RECEIVED;
#endif
}

int16_t parse_cmd_mouse_send (char *cmd, char *output, uint16_t len) 
{
	uint8_t buttons=0;
	int8_t deltax=0;
	int8_t deltay=0;
	sscanf_P(cmd, PSTR("%hhu %hhi %hhi"), &buttons, &deltax, &deltay);
  	USBMOUSEDEBUG("send: %u %i %i\n", buttons, deltax, deltay);

	reportBuffer[0]=buttons; // button
	reportBuffer[1]=deltax; // delta x
	reportBuffer[2]=deltay; // delta y

	flags = FLG_CMD_RECEIVED;

	return ECMD_FINAL_OK;
}


uint16_t
hid_usbFunctionSetup(uchar data[8]) 
{
	usbRequest_t *rq = (void *)data;

    usbMsgPtr = reportBuffer;
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
            /* we only have one report type, so don't look at wValue */
            return sizeof(reportBuffer);
        }
    }else{
        /* no vendor specific requests implemented */
    }
	return 0;

}

/*
  -- Ethersex META --
  header(protocols/usb/usb_hid_mouse.h)
  timer(10,usb_mouse_periodic_call())
  block([[USB]])
  ecmd_ifdef(USB_MOUSE_SUPPORT)
    ecmd_feature(mouse_send, "mouse",BUTTON DELTAX DELTAY,Send data as HID mouse)
  ecmd_endif()
*/

#endif
