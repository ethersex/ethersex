dnl
dnl ipchair.m4
dnl
dnl   Copyright (c) 2008 by Christian Dietrich <stettberger@dokucode.de>
dnl   Copyright (c) 2008 by Stefan Siegl <stesie@brokenpipe.de>
dnl
dnl   This program is free software; you can redistribute it and/or modify
dnl   it under the terms of the GNU General Public License as published by 
dnl   the Free Software Foundation; either version 2 of the License, or
dnl   (at your option) any later version.
dnl  
dnl   This program is distributed in the hope that it will be useful,
dnl   but WITHOUT ANY WARRANTY; without even the implied warranty of
dnl   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
dnl   GNU General Public License for more details.
dnl  
dnl   You should have received a copy of the GNU General Public License
dnl   along with this program; if not, write to the Free Software
dnl   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
dnl  
dnl   For more information on the GPL, please go to:
dnl   http://www.gnu.org/copyleft/gpl.html
dnl
/* This file has been generated by m4 system automatically.
   Please do not modify it, edit the m4 scripts below ipchair/ instead. */

#ifdef IPCHAIR_HEADER
#ifndef __IPCHAIR_HDR
#define __IPCHAIR_HDR

#include "protocols/uip/uip.h"

typedef void builtin_return_t;
typedef uint8_t user_return_t;

divert(1)
#endif /* __IPCHAIR_HDR */
#else
#include "ipchair.h"

#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_TCP ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_UDP ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_ICMP ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define BUF_ICMP6 ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])

/* Structures and definitions. */
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20
#define TCP_CTL 0x3f

#define TCP_OPT_END     0   /* End of TCP options list */
#define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
#define TCP_OPT_MSS     2   /* Maximum segment size TCP option */

#define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */

#define ICMP_ECHO_REPLY 0
#define ICMP_ECHO       8

#define ICMP6_ECHO_REPLY             129
#define ICMP6_ECHO                   128
#define ICMP6_ROUTER_SOLICITATION    133
#define ICMP6_ROUTER_ADVERTISEMENT   134
#define ICMP6_NEIGHBOR_SOLICITATION  135
#define ICMP6_NEIGHBOR_ADVERTISEMENT 136

#define ICMP6_FLAG_S (1 << 6)

#define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
#define ICMP6_OPTION_TARGET_LINK_ADDRESS 2

divert(3)#endif
divert(-1)

define(`forloop',
		`pushdef(`$1', `$2')_forloop(`$1', `$2', `$3', `$4')popdef(`$1')')dnl
		define(`_forloop',
			`$4`'ifelse($1, `$3', ,
				`define(`$1', incr($1))_forloop(`$1', `$2', `$3', `$4')')')dnl

define(`_chair_type', `ifelse(
dnl List all default targets to return builtin here ...
`$1', `INPUT', `builtin',
`$1', `FORWARD', `builtin',
`$1', `PREROUTING', `builtin',
`$1', `POSTROUTING', `builtin',
dnl else ...
`user')')

define(`CHAIR', `divert(0)#define IPCHAIR_HAVE_$1
_chair_type($1)_return_t ipchair_$1_chair(void);

divert(2)
_chair_type($1)_return_t
ipchair_$1_chair(void)
{dnl
define(`__type', _chair_type($1))dnl
')

define(`LEG', `if (_ipchair_arg_loop($@)')
define(`_ipchair_arg_loop', `dnl
dnl Destination IP Address
ifelse(`$1', `-d', `ipchair_dst($2) && $0(shift(shift($@)))')dnl
ifelse(`$1', `! -d', `!(ipchair_dst($2)) && $0(shift(shift($@)))')dnl
dnl Source IP Address
ifelse(`$1', `-s', `ipchair_src($2) && $0(shift(shift($@)))')dnl
ifelse(`$1', `! -s', `!(ipchair_src($2)) && $0(shift(shift($@)))')dnl
dnl Proto
ifelse(`$1', `-p', `ipchair_proto($2) && $0(shift(shift($@)))')dnl
dnl Source and Destination Ports
ifelse(`$1', `--dport', `ipchair_dport($2) && $0(shift(shift($@)))')dnl
ifelse(`$1', `! --dport', `!(ipchair_dport($2)) && $0(shift(shift($@)))')dnl
ifelse(`$1', `--sport', `ipchair_sport($2) && $0(shift(shift($@)))')dnl
ifelse(`$1', `! --sport', `!(ipchair_sport($2)) && $0(shift(shift($@)))')dnl
dnl TCP Flags
ifelse(`$1', `--tcp-flags', `ipchair_tcp_flags($2, $3) && $0(shift(shift(shift($@))))')dnl
ifelse(`$1', `! --tcp-flags', `!(ipchair_tcp_flags($2, $3)) && $0(shift(shift(shift($@))))')dnl
ifelse(`$1', `--syn', `ipchair_tcp_flags(`SYN:RST:ACK:FIN', `SYN') && $0(shift($@))')dnl
ifelse(`$1', `! --syn', `!(ipchair_tcp_flags(`SYN:RST:ACK:FIN', `SYN')) && $0(shift($@))')dnl
dnl ICMP Type
ifelse(`$1', `--icmp-type', `ipchair_icmp_type($2) && $0(shift(shift($@)))')dnl
dnl Stack
ifelse(`$1', `--stack', `ipchair_stack($2) && $0(shift(shift($@)))')dnl
ifelse(`$1', `! --stack', `!(ipchair_stack($2)) && $0(shift(shift($@)))')dnl
dnl Target
ifelse(`$1', `-j', `1) __target(shift($@))undefine(`__proto')')dnl
')

# Yippieyah voodoo
define(`ipchair_addr', `ifelse(regexp($1, `:'), `-1', `translit(`$1', `.', `,')', indir(`regexp', `$1', `\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\)', ``0x\1,0x\2,0x\3,0x\4,0x\5,0x\6,0x\7,0x\8''))') 

define(`__paste2', `$1$2')
#######
# Tests
#######
define(`ipchair_dst', `uip_ipaddr_cmp_instant(BUF->destipaddr, ipchair_addr($1))') 
define(`ipchair_src', `uip_ipaddr_cmp_instant(BUF->srcipaddr, ipchair_addr($1))') 
define(`ipchair_proto',  `define(`__proto', translit(`$1', `a-z', `A-Z'))BUF->proto == __paste2(`UIP_PROTO_', translit(`$1', `a-z', `A-Z'))') 
define(`ipchair_dport', `__paste2(`BUF_', indir(`__proto'))->destport == HTONS($1)') 
define(`ipchair_stack', `uip_stack_get_active() == $1') 
define(`ipchair_sport', `__paste2(`BUF_', indir(`__proto'))->srcport == HTONS($1)') 
define(`ipchair_tcp_flags', `(((BUF_TCP->flags) & (0 patsubst(`:'translit(`$1', `a-z', `A-Z'), `:', ` | TCP_'))) == (0 patsubst(`:'translit(`$2', `a-z', `A-Z'), `:', ` | TCP_')))')
define(`ipchair_icmp_type', `__paste2(`BUF_', indir(`__proto'))->type == __paste2(__paste2(indir(`__proto'),_),translit(`$1', `a-z', `A-Z'))') 
######
# Targets
######
define(`__target', `ifelse(
`$1', `DROP', ` {
    uip_len = 0;
    return ifelse(__type, `builtin',, 0);
  }',
`$1', `ACCEPT', ` {
    return ifelse(__type, `builtin',, 0);
  }',
`$1', `RETURN', ` {
    ifelse(__type, `builtin', `goto policy', `return 1');
  }',
dnl Else
`divert(1)#ifndef IPCHAIR_NEED_$1
#define IPCHAIR_NEED_$1 1
#endif
divert(2){ 
    if(ipchair_$1_chair(shift($@)) == 0)
      return ifelse(__type, `builtin',, 0);
  }')')

define(`POLICY', `
  ifelse(__type, `builtin', `policy:')
  if(1) __target($1)
  ifelse(__type, `user', `/* call failed, continue in parent */ return 1;')
}')

define(`SET_STACK', `uip_stack_set_active(STACK_$1); ')


divert(0)dnl
